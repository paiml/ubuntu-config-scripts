// Test parse_args in isolation

use std::collections::HashMap;

// Parse command-line arguments
fun parse_args(args: Vec<String>) -> HashMap<String, String> {
    let mut parsed = HashMap::new();
    let mut i = 0;

    while i < args.len() {
        let arg = &args[i];

        if arg.starts_with("--") {
            let key_part = &arg[2..];

            if let Some(eq_pos) = key_part.find('=') {
                let key = &key_part[0..eq_pos];
                let value = &key_part[eq_pos + 1..];
                parsed.insert(key.to_string(), value.to_string());
            } else {
                if i + 1 < args.len() && !args[i + 1].starts_with('-') {
                    i += 1;
                    parsed.insert(key_part.to_string(), args[i].clone());
                } else {
                    parsed.insert(key_part.to_string(), String::from("true"));
                }
            }
        } else if arg.starts_with('-') && arg.len() == 2 {
            let key = &arg[1..];

            if i + 1 < args.len() && !args[i + 1].starts_with('-') {
                i += 1;
                parsed.insert(key.to_string(), args[i].clone());
            } else {
                parsed.insert(key.to_string(), String::from("true"));
            }
        }

        i += 1;
    }

    parsed
}

fun main() {
    let test_args = vec![
        String::from("--verbose"),
        String::from("--name"),
        String::from("test"),
        String::from("--count=42"),
    ];

    let result = parse_args(test_args);

    println!("Parsed {} arguments", result.len());
}
