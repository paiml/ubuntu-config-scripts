#!/usr/bin/env ruchy
// System Diagnostic Tool - Showcase for Ruchy Language
// Demonstrates Ruchy's capabilities for system administration
// Follows PMAT TDG guidelines: Low complexity, high cohesion

use std::fs;
use std::process::Command;
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use serde_json;

// Data structures for system information
#[derive(Debug, Clone, Serialize, Deserialize)]
struct SystemInfo {
    hostname: String,
    kernel: String,
    uptime_seconds: u64,
    cpu_count: u32,
    memory_total_kb: u64,
    memory_available_kb: u64,
    disk_usage: Vec<DiskUsage>,
    network_interfaces: Vec<NetworkInterface>,
    services: Vec<ServiceStatus>,
    timestamp: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct DiskUsage {
    mount_point: String,
    filesystem: String,
    total_bytes: u64,
    used_bytes: u64,
    available_bytes: u64,
    usage_percent: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct NetworkInterface {
    name: String,
    ip_address: String,
    mac_address: String,
    is_up: bool,
    speed_mbps: Option<u32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceStatus {
    name: String,
    is_active: bool,
    is_enabled: bool,
    description: String,
}

// Result type for error handling
type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

// Get CPU count from /proc/cpuinfo
fun get_cpu_count() -> u32 {
    let cpuinfo = fs::read_to_string("/proc/cpuinfo")
        .unwrap_or_default();
    
    cpuinfo.lines()
        .filter(|line| line.starts_with("processor"))
        .count() as u32
}

// Get memory information from /proc/meminfo
fun get_memory_info() -> (u64, u64) {
    let meminfo = fs::read_to_string("/proc/meminfo")
        .unwrap_or_default();
    
    let mut total = 0u64;
    let mut available = 0u64;
    
    for line in meminfo.lines() {
        if line.starts_with("MemTotal:") {
            total = parse_kb_value(line);
        } else if line.starts_with("MemAvailable:") {
            available = parse_kb_value(line);
        }
    }
    
    (total, available)
}

// Parse KB value from /proc/meminfo line
fun parse_kb_value(line: &str) -> u64 {
    line.split_whitespace()
        .nth(1)
        .and_then(|s| s.parse().ok())
        .unwrap_or(0)
}

// Get disk usage using df command
fun get_disk_usage() -> Vec<DiskUsage> {
    let output = Command::new("df")
        .args(&["-B1", "--output=source,target,size,used,avail,pcent"])
        .output()
        .unwrap_or_default();
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    let mut disks = Vec::new();
    
    for line in stdout.lines().skip(1) {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() >= 6 {
            let total = parts[2].parse().unwrap_or(0);
            let used = parts[3].parse().unwrap_or(0);
            let available = parts[4].parse().unwrap_or(0);
            let percent_str = parts[5].trim_end_matches('%');
            let percent = percent_str.parse::<f32>().unwrap_or(0.0);
            
            disks.push(DiskUsage {
                filesystem: parts[0].to_string(),
                mount_point: parts[1].to_string(),
                total_bytes: total,
                used_bytes: used,
                available_bytes: available,
                usage_percent: percent,
            });
        }
    }
    
    // Filter to only physical disks and important mounts
    disks.into_iter()
        .filter(|d| !d.filesystem.starts_with("tmpfs") && 
                    !d.filesystem.starts_with("devtmpfs") &&
                    !d.mount_point.starts_with("/snap"))
        .collect()
}

// Get network interfaces using ip command
fun get_network_interfaces() -> Vec<NetworkInterface> {
    let output = Command::new("ip")
        .args(&["-j", "addr", "show"])
        .output()
        .unwrap_or_default();
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    let mut interfaces = Vec::new();
    
    // Parse JSON output from ip command
    if let Ok(json_data) = serde_json::from_str::<Vec<serde_json::Value>>(&stdout) {
        for iface in json_data {
            if let Some(name) = iface["ifname"].as_str() {
                let is_up = iface["operstate"].as_str() == Some("UP");
                let mut ip_address = String::new();
                
                if let Some(addr_info) = iface["addr_info"].as_array() {
                    for addr in addr_info {
                        if addr["family"].as_str() == Some("inet") {
                            ip_address = addr["local"].as_str()
                                .unwrap_or("")
                                .to_string();
                            break;
                        }
                    }
                }
                
                let mac_address = iface["address"].as_str()
                    .unwrap_or("")
                    .to_string();
                
                interfaces.push(NetworkInterface {
                    name: name.to_string(),
                    ip_address,
                    mac_address,
                    is_up,
                    speed_mbps: None,
                });
            }
        }
    }
    
    interfaces
}

// Check service status using systemctl
fun check_services(service_names: &[&str]) -> Vec<ServiceStatus> {
    let mut statuses = Vec::new();
    
    for name in service_names {
        let status = check_service_safe(name)
            .unwrap_or(ServiceStatus {
                name: name.to_string(),
                is_active: false,
                is_enabled: false,
                description: "Unknown".to_string(),
            });
        statuses.push(status);
    }
    
    statuses
}

// Safe service check with error handling
fun check_service_safe(name: &str) -> Result<ServiceStatus> {
    let active_output = Command::new("systemctl")
        .args(&["is-active", name])
        .output()?;
    
    let enabled_output = Command::new("systemctl")
        .args(&["is-enabled", name])
        .output()?;
    
    let show_output = Command::new("systemctl")
        .args(&["show", name, "--property=Description"])
        .output()?;
    
    let is_active = String::from_utf8_lossy(&active_output.stdout)
        .trim() == "active";
    
    let is_enabled = String::from_utf8_lossy(&enabled_output.stdout)
        .trim() == "enabled";
    
    let description = String::from_utf8_lossy(&show_output.stdout)
        .trim()
        .strip_prefix("Description=")
        .unwrap_or("Unknown")
        .to_string();
    
    Ok(ServiceStatus {
        name: name.to_string(),
        is_active,
        is_enabled,
        description,
    })
}

// Get system uptime in seconds
fun get_uptime_seconds() -> u64 {
    let uptime = fs::read_to_string("/proc/uptime")
        .unwrap_or_default();
    
    uptime.split_whitespace()
        .next()
        .and_then(|s| s.parse::<f64>().ok())
        .unwrap_or(0.0) as u64
}

// Get hostname
fun get_hostname() -> String {
    fs::read_to_string("/etc/hostname")
        .unwrap_or_default()
        .trim()
        .to_string()
}

// Get kernel version
fun get_kernel_version() -> String {
    let output = Command::new("uname")
        .arg("-r")
        .output()
        .unwrap_or_default();
    
    String::from_utf8_lossy(&output.stdout)
        .trim()
        .to_string()
}

// Collect all system information
fun collect_system_info() -> SystemInfo {
    let (mem_total, mem_available) = get_memory_info();
    
    // Critical services to check
    let services = vec![
        "ssh", "systemd-resolved", "NetworkManager",
        "docker", "nginx", "postgresql", "mysql"
    ];
    
    SystemInfo {
        hostname: get_hostname(),
        kernel: get_kernel_version(),
        uptime_seconds: get_uptime_seconds(),
        cpu_count: get_cpu_count(),
        memory_total_kb: mem_total,
        memory_available_kb: mem_available,
        disk_usage: get_disk_usage(),
        network_interfaces: get_network_interfaces(),
        services: check_services(&services),
        timestamp: chrono::Utc::now().to_rfc3339(),
    }
}

// Convert to JSON
fun system_info_to_json(info: &SystemInfo) -> String {
    serde_json::to_string_pretty(info)
        .unwrap_or_else(|_| "{}".to_string())
}

// Format bytes to human readable
fun format_bytes(bytes: u64) -> String {
    const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB"];
    let mut size = bytes as f64;
    let mut unit_idx = 0;
    
    while size >= 1024.0 && unit_idx < UNITS.len() - 1 {
        size /= 1024.0;
        unit_idx += 1;
    }
    
    format!("{:.2} {}", size, UNITS[unit_idx])
}

// Format uptime to human readable
fun format_uptime(seconds: u64) -> String {
    let days = seconds / 86400;
    let hours = (seconds % 86400) / 3600;
    let minutes = (seconds % 3600) / 60;
    
    if days > 0 {
        format!("{} days, {} hours, {} minutes", days, hours, minutes)
    } else if hours > 0 {
        format!("{} hours, {} minutes", hours, minutes)
    } else {
        format!("{} minutes", minutes)
    }
}

// Format as human-readable text
fun format_human_readable(info: &SystemInfo) -> String {
    let mut output = String::new();
    
    output.push_str("╔══════════════════════════════════════════════════════════════╗\n");
    output.push_str("║           System Diagnostic Report - Ruchy Edition          ║\n");
    output.push_str("╚══════════════════════════════════════════════════════════════╝\n\n");
    
    output.push_str(&format!("🖥️  Hostname:    {}\n", info.hostname));
    output.push_str(&format!("🐧 Kernel:      {}\n", info.kernel));
    output.push_str(&format!("⏱️  Uptime:      {}\n", format_uptime(info.uptime_seconds)));
    output.push_str(&format!("🔧 CPUs:        {} CPUs\n", info.cpu_count));
    output.push_str(&format!("💾 Memory:      {} / {} ({}% used)\n",
        format_bytes(info.memory_total_kb * 1024 - info.memory_available_kb * 1024),
        format_bytes(info.memory_total_kb * 1024),
        ((info.memory_total_kb - info.memory_available_kb) * 100 / info.memory_total_kb)
    ));
    
    output.push_str("\n📁 Disk Usage:\n");
    for disk in &info.disk_usage {
        output.push_str(&format!("  {} ({}): {} / {} ({:.1}%)\n",
            disk.mount_point,
            disk.filesystem,
            format_bytes(disk.used_bytes),
            format_bytes(disk.total_bytes),
            disk.usage_percent
        ));
    }
    
    output.push_str("\n🌐 Network Interfaces:\n");
    for iface in &info.network_interfaces {
        let status = if iface.is_up { "UP" } else { "DOWN" };
        output.push_str(&format!("  {} [{}]: {}\n",
            iface.name, status, iface.ip_address
        ));
    }
    
    output.push_str("\n⚙️  Services:\n");
    for service in &info.services {
        let status = match (service.is_active, service.is_enabled) {
            (true, true) => "✅ Active & Enabled",
            (true, false) => "🟡 Active (Not Enabled)",
            (false, true) => "🔴 Inactive (Enabled)",
            (false, false) => "⭕ Inactive & Disabled",
        };
        output.push_str(&format!("  {} {}\n", service.name, status));
    }
    
    output.push_str(&format!("\n📅 Generated: {}\n", info.timestamp));
    
    output
}

// Main diagnostic runner
fun run_system_diagnostic() -> Result<SystemInfo> {
    Ok(collect_system_info())
}

// Main entry point
fun main() {
    println!("🚀 Ruchy System Diagnostic Tool v1.0.0");
    println!("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    
    match run_system_diagnostic() {
        Ok(info) => {
            // Check for JSON output flag
            let args: Vec<String> = std::env::args().collect();
            if args.contains(&"--json".to_string()) {
                println!("{}", system_info_to_json(&info));
            } else {
                println!("{}", format_human_readable(&info));
            }
        }
        Err(e) => {
            eprintln!("❌ Error collecting system information: {}", e);
            std::process::exit(1);
        }
    }
}