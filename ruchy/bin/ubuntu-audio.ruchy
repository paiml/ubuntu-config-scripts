// RUC-002: Ubuntu Audio CLI Tool
//
// Command-line interface for audio speaker configuration
// Uses RUC-001 library functions (inlined for now)

use std::process::Command;

// ============================================================================
// Data Structures (from RUC-001)
// ============================================================================

struct AudioDevice {
    id: String,
    name: String,
    description: String,
    is_default: bool,
}

struct SpeakerConfig {
    device_id: String,
    volume: i32,
    is_muted: bool,
}

enum ConfigError {
    CommandFailed(String),
    ParseError(String),
    DeviceNotFound(String),
    InvalidState(String),
}

// ============================================================================
// Library Functions (from RUC-001)
// ============================================================================

fun bytes_to_string(bytes: Vec<u8>) -> Result<String, ConfigError> {
    match String::from_utf8(bytes) {
        Ok(s) => Ok(s),
        Err(e) => Err(ConfigError::ParseError(format!("Invalid UTF-8: {:?}", e))),
    }
}

fun extract_field(text: String, field: String) -> String {
    let lines = text.split("\n");
    let mut i = 0;
    while i < lines.len() {
        let line = lines[i];
        let trimmed = line.trim();
        if trimmed.starts_with(&field) {
            let parts = line.split(":");
            if parts.len() >= 2 {
                return parts[1].trim().to_string();
            }
        }
        i = i + 1;
    }
    "".to_string()
}

fun parse_volume_from_line(line: String) -> i32 {
    let parts = line.split("%");
    if parts.len() >= 2 {
        let before_percent = parts[0];
        let words = before_percent.split(" ");
        let mut last_word = "";
        let mut i = 0;
        while i < words.len() {
            last_word = words[i];
            i = i + 1;
        }
        match last_word.parse::<i32>() {
            Ok(v) => {
                if v < 0 { return 0; }
                if v > 100 { return 100; }
                return v;
            }
            Err(_) => return 100,
        }
    }
    100
}

fun parse_pactl_output(stdout: Vec<u8>, default_sink: String) -> Result<Vec<AudioDevice>, ConfigError> {
    let text = match bytes_to_string(stdout) {
        Ok(s) => s,
        Err(e) => return Err(e),
    };
    let blocks = text.split("Sink #");
    let mut devices: Vec<AudioDevice> = Vec::new();

    let mut i = 0;
    while i < blocks.len() {
        let block = blocks[i];
        if block.trim().len() == 0 {
            i = i + 1;
            continue;
        }

        let lines = block.split("\n");
        let id = if lines.len() > 0 {
            let first_line = lines[0];
            let words = first_line.split(" ");
            if words.len() > 0 {
                words[0].trim().to_string()
            } else {
                "".to_string()
            }
        } else {
            "".to_string()
        };

        let name = extract_field(block, "Name:");
        let name = if name.len() == 0 {
            format!("sink-{}", id)
        } else {
            name
        };

        let description = extract_field(block, "Description:");
        let description = if description.len() == 0 {
            name.to_string()
        } else {
            description
        };

        let is_default = name == default_sink;

        if id.len() > 0 {
            devices.push(AudioDevice {
                id: id,
                name: name,
                description: description,
                is_default: is_default,
            });
        }
        i = i + 1;
    }
    Ok(devices)
}

fun detect_audio_devices() -> Result<Vec<AudioDevice>, ConfigError> {
    let output = match Command::new("pactl").arg("list").arg("sinks").output() {
        Ok(o) => o,
        Err(e) => return Err(ConfigError::CommandFailed(format!("Failed to run pactl: {:?}", e))),
    };

    if !output.status.success {
        return Err(ConfigError::CommandFailed("pactl list sinks failed".to_string()));
    }

    let default_output = match Command::new("pactl").arg("get-default-sink").output() {
        Ok(o) => o,
        Err(_) => return parse_pactl_output(output.stdout, "".to_string()),
    };

    let default_sink = if default_output.status.success {
        match bytes_to_string(default_output.stdout) {
            Ok(s) => s.trim().to_string(),
            Err(_) => "".to_string(),
        }
    } else {
        "".to_string()
    };

    parse_pactl_output(output.stdout, default_sink)
}

fun get_current_speaker_config() -> Result<SpeakerConfig, ConfigError> {
    let output = match Command::new("pactl").arg("get-default-sink").output() {
        Ok(o) => o,
        Err(e) => return Err(ConfigError::CommandFailed(format!("Failed to get default sink: {:?}", e))),
    };

    if !output.status.success {
        return Err(ConfigError::InvalidState("No default sink configured".to_string()));
    }

    let device_id = match bytes_to_string(output.stdout) {
        Ok(s) => s.trim().to_string(),
        Err(e) => return Err(e),
    };

    let info_output = match Command::new("pactl").arg("list").arg("sinks").output() {
        Ok(o) => o,
        Err(e) => return Err(ConfigError::CommandFailed(format!("Failed to list sinks: {:?}", e))),
    };

    let info_stdout = match bytes_to_string(info_output.stdout) {
        Ok(s) => s,
        Err(e) => return Err(e),
    };

    let blocks = info_stdout.split("Sink #");
    let mut sink_block = "";
    let mut i = 0;
    let mut found = false;
    while i < blocks.len() {
        let block = blocks[i];
        let name_field = extract_field(block, "Name:");
        if name_field == device_id {
            sink_block = block;
            found = true;
            break;
        }
        i = i + 1;
    }

    if !found {
        return Err(ConfigError::DeviceNotFound(device_id));
    }

    let volume_str = extract_field(sink_block, "Volume:");
    let volume = if volume_str.len() > 0 {
        parse_volume_from_line(volume_str)
    } else {
        100
    };

    let mute_str = extract_field(sink_block, "Mute:");
    let is_muted = mute_str.trim() == "yes";

    Ok(SpeakerConfig {
        device_id: device_id,
        volume: volume,
        is_muted: is_muted,
    })
}

fun validate_device_id(device_id: String) -> bool {
    if device_id.len() == 0 { return false; }
    if device_id.contains("\0") { return false; }
    if device_id.contains("..") { return false; }
    if device_id.contains("/") { return false; }
    if device_id.contains(" ") { return false; }
    true
}

fun configure_speaker(device_id: String) -> Result<(), ConfigError> {
    if device_id.len() == 0 {
        return Err(ConfigError::InvalidState("Device ID cannot be empty".to_string()));
    }

    if device_id.contains("\0") || device_id.contains("..") {
        return Err(ConfigError::InvalidState(format!("Invalid device ID format: {}", device_id)));
    }

    let original_config = match get_current_speaker_config() {
        Ok(c) => c,
        Err(e) => return Err(e),
    };

    let devices = match detect_audio_devices() {
        Ok(d) => d,
        Err(e) => return Err(e),
    };

    let mut device_found: Option<AudioDevice> = None;
    let mut i = 0;
    while i < devices.len() {
        let d = &devices[i];
        if d.id == device_id || d.name == device_id {
            // Copy fields manually since clone() not available
            device_found = Some(AudioDevice {
                id: d.id.to_string(),
                name: d.name.to_string(),
                description: d.description.to_string(),
                is_default: d.is_default,
            });
            break;
        }
        i = i + 1;
    }

    let device = match device_found {
        Some(d) => d,
        None => return Err(ConfigError::DeviceNotFound(device_id)),
    };

    let output = match Command::new("pactl").arg("set-default-sink").arg(&device.name).output() {
        Ok(o) => o,
        Err(_) => {
            let _ = Command::new("pactl").arg("set-default-sink").arg(&original_config.device_id).output();
            return Err(ConfigError::CommandFailed("Failed to set default sink".to_string()));
        }
    };

    if !output.status.success {
        let _ = Command::new("pactl").arg("set-default-sink").arg(&original_config.device_id).output();
        return Err(ConfigError::CommandFailed("set-default-sink failed".to_string()));
    }

    let config = match get_current_speaker_config() {
        Ok(c) => c,
        Err(e) => {
            let _ = Command::new("pactl").arg("set-default-sink").arg(&original_config.device_id).output();
            return Err(e);
        }
    };

    if config.device_id != device.name {
        let _ = Command::new("pactl").arg("set-default-sink").arg(&original_config.device_id).output();
        return Err(ConfigError::InvalidState("Configuration not applied correctly".to_string()));
    }

    Ok(())
}

// ============================================================================
// CLI Command Handlers
// ============================================================================

fun cmd_help() {
    println!("Ubuntu Audio Configuration Tool");
    println!("");
    println!("USAGE:");
    println!("  ubuntu-audio <command> [arguments]");
    println!("");
    println!("COMMANDS:");
    println!("  list                List all audio devices");
    println!("  current             Show current speaker configuration");
    println!("  set <device>        Set default speaker (by ID or name)");
    println!("  validate <id>       Validate device ID format");
    println!("  help, --help        Show this help message");
    println!("");
    println!("EXAMPLES:");
    println!("  ubuntu-audio list");
    println!("  ubuntu-audio current");
    println!("  ubuntu-audio set alsa_output.usb-ACTIONS_Pebble_V3-00.analog-stereo");
    println!("  ubuntu-audio validate test-device");
}

fun cmd_list() -> Result<(), ConfigError> {
    let devices = match detect_audio_devices() {
        Ok(d) => d,
        Err(e) => return Err(e),
    };

    println!("Available Audio Devices:");
    println!("");

    if devices.len() == 0 {
        println!("  No audio devices found");
        return Ok(());
    }

    let mut i = 0;
    while i < devices.len() {
        let d = &devices[i];
        let marker = if d.is_default { "* " } else { "  " };
        println!("{}[{}] {}", marker, d.id, d.name);
        println!("  Description: {}", d.description);
        if d.is_default {
            println!("  (Current default)");
        }
        println!("");
        i = i + 1;
    }

    Ok(())
}

fun cmd_current() -> Result<(), ConfigError> {
    println!("Querying current speaker configuration...");

    let config = match get_current_speaker_config() {
        Ok(c) => c,
        Err(e) => {
            println!("Error getting config: {:?}", e);
            return Err(e);
        }
    };

    println!("Current Speaker Configuration:");
    println!("");
    println!("  Device: {}", config.device_id);
    println!("  Volume: {}%", config.volume);
    let mute_status = if config.is_muted { "yes" } else { "no" };
    println!("  Muted: {}", mute_status);

    Ok(())
}

fun cmd_set(device_id: String) -> Result<(), ConfigError> {
    println!("Configuring speaker: {}", device_id);

    match configure_speaker(device_id) {
        Ok(_) => {
            println!("✓ Successfully configured speaker");
            let config = match get_current_speaker_config() {
                Ok(c) => c,
                Err(_) => return Ok(()),
            };
            println!("  Device: {}", config.device_id);
            Ok(())
        }
        Err(e) => Err(e),
    }
}

fun cmd_validate(device_id: String) {
    println!("Validating device ID: '{}'", device_id);

    if validate_device_id(device_id.to_string()) {
        println!("✓ Valid device ID format");
    } else {
        println!("✗ Invalid device ID format");
        println!("");
        println!("Device IDs must:");
        println!("  - Not be empty");
        println!("  - Not contain null bytes");
        println!("  - Not contain path traversal (../)");
        println!("  - Not contain spaces");
    }
}

// ============================================================================
// Main
// ============================================================================

fun main() {
    // For now, print usage since we can't access command-line args easily
    // This is a limitation we'll work around

    println!("Ubuntu Audio CLI - Demo Mode");
    println!("");
    println!("Running all commands to demonstrate functionality:");
    println!("");

    // Demo: List devices
    println!("=== COMMAND: list ===");
    let list_result = cmd_list();
    match list_result {
        Ok(_) => println!(""),
        Err(e) => {
            println!("Error: {:?}", e);
            println!("");
        }
    }

    // Demo: Show current
    println!("=== COMMAND: current ===");
    let current_result = cmd_current();
    match current_result {
        Ok(_) => println!(""),
        Err(e) => {
            println!("Error: {:?}", e);
            println!("");
        }
    }

    println!("");

    // Demo: Validate
    println!("=== COMMAND: validate test-device ===");
    cmd_validate("test-device".to_string());

    println!("");
    println!("=== COMMAND: validate ../bad ===");
    cmd_validate("../bad".to_string());

    println!("");
    println!("=== COMMAND: help ===");
    cmd_help();
}
